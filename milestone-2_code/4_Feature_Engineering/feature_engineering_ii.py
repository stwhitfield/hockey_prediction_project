#!/usr/bin/env python
# coding: utf-8

# Primary author: Anuj Saini <br>
# Secondary author: Shawn Whitfield <br>
# Version: 2<br>
# <br>
# 2022-11-13
# SW changes: <br>
# -Changed feature titles to be more informative or clearer <br>
# -Changed Last Angle From Net feature to be the difference between it and the new angle <br>
# 2022-11-16
# SW changes: <br>
# -added code to take bonus features added by Luis (in tidy4.csv) and add to dataframe <br>
#     -changed home and away players on ice to friendly and opposing players on ice <br>
# -removed NAs generated by Anuj's code. <br>
# 

import json
import pandas as pd
import csv
import os

current_periods = []
current_teams = tuple()
nullToken = None


def valueOrNull(key, obj):
        if key in obj:
            value = obj[key]
        else:
            value = nullToken
        return value


def getPlayInfo(play):
        about = play["about"]
        periodTime = about["periodTime"]
        period = about["period"]
        eventTeam = play["team"]["name"]
        if(period == 5):
            eventSide = "shootout"
        else:
            team = current_teams.index(eventTeam)
            current_period = current_periods[period - 1]
            if team == 0:
                eventSide = valueOrNull("rinkSide", current_period["home"])
            else:
                eventSide = valueOrNull("rinkSide", current_period["away"])
        result = play["result"]
        eventType = result["event"]
        if eventType == "Goal":
            eventType = 1
        else:
            eventType = 0
        coordinates = play["coordinates"]
        coordinateX = valueOrNull("x", coordinates)
        coordinateY = valueOrNull("y", coordinates)
        shooterName = play["players"][0]["player"]["fullName"]
        goalieName = play["players"][-1]["player"]["fullName"]
        shotType = valueOrNull("secondaryType", result)
        if eventType == 1:
            emptyNet = valueOrNull("emptyNet", result)
            strength = result["strength"]["code"]
        else:
            emptyNet = nullToken
            strength = nullToken
        return [eventType, eventTeam, period, periodTime, eventSide, coordinateX, coordinateY, shooterName, goalieName, shotType, emptyNet, strength]


import numpy as np
def get_distance(x1,x2, y1,y2):
    """
    Calculates the euclidean distance from the event coordinates (x,y) to the goal, 
    based on what side of the rink (Eventside) the event is.
    Returns the euclidean distance rounded to 4 decimal places.
    """
    coord1 = np.array([x1,x2])
    coord2 = np.array([y1,y2])
    
    
    # Distance is the norm of a-b
    try:
        distance = np.linalg.norm(coord1 - coord2)
    except:
        distance = 0
    return round(distance,4)


#Get time differece
import datetime as dt
def get_time_diff(t1, t2):
    start_dt = dt.datetime.strptime(t1, '%M:%S')
    end_dt = dt.datetime.strptime(t2, '%M:%S')
    diff = (end_dt - start_dt) 
    return diff.seconds 



f = open('tidy_features.csv', 'w', newline='')

# create the csv writer
csv_writer = csv.writer(f)

csv_writer.writerow(["gameId", "season", "teamHome", "teamAway", "eventType", "eventTeam", "period", "periodTime",
                        "eventSide", "coordinateX", "coordinateY", "shooterName", "goalieName", "shotType", 
                        "emptyNet", "strength", "last_coordinateX", "last_coordinateY", "lastEventType",
                        "last_periodTime","last_distanceFromNet","time_from_lastEvent", "rebound", "speed"])

json_files = sorted(filter(lambda x: os.path.isfile(os.path.join("raw_data", x)), os.listdir("raw_data")))
for filename in json_files:
    # Parse the filename
    name = filename.split('.json')[0]
    is_json = filename[-5:] == '.json'
    print(filename)
    # If it's a json:
    if is_json:
        # Open and load file
        json_file = open("raw_data/"+filename)
        data = json.load(json_file)
        gameId = data["gamePk"]
        season = data["gameData"]["game"]["season"]
        teamHome = data["gameData"]["teams"]["home"]["name"]
        teamAway = data["gameData"]["teams"]["away"]["name"]
        current_teams = (teamHome, teamAway)
        periods = data["liveData"]["linescore"]["periods"]
        current_periods = periods
        allplays=data["liveData"]["plays"]["allPlays"]
        for i in range(0,len(allplays)):
            if allplays[i]["result"]["event"] == "Shot" or allplays[i]["result"]["event"] == "Goal":
                play= getPlayInfo(allplays[i])
                last_coordinates = allplays[i-1]["coordinates"]
                last_coordinateX = valueOrNull("x", last_coordinates)
                last_coordinateY = valueOrNull("y", last_coordinates)
                last_event = allplays[i-1]["result"]["event"]
                last_periodTime = allplays[i-1]["about"]["periodTime"]
                if last_coordinateX is None :
                    last_coordinateX = play[5]
                if last_coordinateY is None :
                    last_coordinateY = play[6]
                lastDistance = get_distance(play[5], play[6], last_coordinateX, last_coordinateY)
                time_last_event = get_time_diff(last_periodTime, play[3])
                rebound=False
                if last_event=="Shot":
                    rebound=True
                speed=0
                if time_last_event!=0:
                    speed=lastDistance/time_last_event
                csv_writer.writerow([gameId,season,teamHome,teamAway] + play + [last_coordinateX, last_coordinateY,
                                    last_event, last_periodTime, lastDistance, time_last_event, rebound, round(speed, 4)])
        json_file.close()
    #break              
f.close()


#Reading csv
df = pd.read_csv('tidy_features.csv')

# Clean the file of NA in eventSide, coordinateX or coordinateY
df = df.dropna(axis=0, subset=['eventSide','coordinateX','coordinateY'])
print(df.columns[df.isnull().any()].tolist())


def get_distance_from_post(eventSide,x,y):
    """
    Calculates the euclidean distance from the event coordinates (x,y) to the goal, 
    based on what side of the rink (Eventside) the event is.
    Returns the euclidean distance rounded to 4 decimal places.
    """
    event_pos = np.array([x,y])
    
    # Set the goal position based on the event side (the eventSide marks the team making the shot, the goal is on other side)
    if eventSide == 'right':
        goal_pos = np.array([-89.0,0.0])
    else:
        goal_pos = np.array([89.0,0.0])
    
    # Distance is the norm of a-b
    distance = np.linalg.norm(event_pos - goal_pos)
    
    return round(distance,4)

def get_angle(eventSide,x,y):
    """
    Calculates the angle between the goal (treated as the origin) and the event coordinates (x,y).
    Returns the angle in degrees, rounded to 4 decimal places.
    """
    # Set the goal position as (0,0)
    goal_pos = np.array([0.0,0.0])
    
    # Adjust the event coordinates to account for the goal being at position (0,0)
    # x is moved left or right by 89 depending on eventSide, y is unchanged.
    if eventSide == 'right':
        event_pos = np.array([x+89.0,y])
    else:
        # if eventSide team is on the left, flip it so it's on the right and then adjust
        # This is done so the angle is correct with relation to the net
        event_pos = np.array([(-x)+89.0,y])
        
    # Angle from origin to point (x,y) is np.arctan2()
    angle = np.arctan2(event_pos[1],event_pos[0])
    
    # Convert the angle to degrees and return
    return round(np.rad2deg(angle),4)

def bool_to_digit(x):
    """
    Turns a True to 1 and anything else to 0.
    """
    if x == True:
        return 1
    else:
        return 0



def periodTime_to_seconds(period, periodTime):
    """
    Takes a period (numpy.int64) and a periodTime (string in format 'mm:ss')  
    and returns the number of seconds since the beginning of the game.
    """
    periodSecs = (period-1)*20*60 # periods are 20 mins, 60 secs per min
    
    mins = int(periodTime.split(':')[0]) * 60 # multiply num mins by 60
    secs = int(periodTime.split(':')[1]) # seconds are fine as is
    totalSecs = periodSecs + mins + secs
    return totalSecs


# Use clunky list comprehensions to get lists that apply functions that use different dataframe columns 
df["distanceFromNet"] = [get_distance_from_post(df['eventSide'][i],df['coordinateX'][i],df['coordinateY'][i]) for i,r, in df.iterrows()]
df["angleFromNet"] = [get_angle(df['eventSide'][i],df['coordinateX'][i],df['coordinateY'][i]) for i,r, in df.iterrows()] 
df["angleFromNetLastEvent"] = [get_angle(df['eventSide'][i],df['last_coordinateX'][i],df['last_coordinateY'][i]) for i,r, in df.iterrows()] 
df["isGoal"] = df['eventType']
df["emptyNet"] = [bool_to_digit(df['emptyNet'][i]) for i,r in df.iterrows()]
df['gameSeconds'] = [periodTime_to_seconds(df['period'][i],df['periodTime'][i])  for i,r in df.iterrows()]



#df['angleFromNetLastEvent'] = df["rebound"]==True
df["changeShotAngle"] = np.where(df["rebound"] == True, round((df['angleFromNet'] - df['angleFromNetLastEvent']), 4), 0)


# Read in the csv that contains extra features generated by Luis (run tidy4.csv for this)
extra_feat = pd.read_csv('tidy.csv')


# Give both new and old dataframes a "unique identifier" column:
df['identifier'] = df['gameId'].astype(str) + df['eventTeam'].astype(str) + df['period'].astype(str) + df['periodTime'].astype(str)
extra_feat['identifier'] = extra_feat['gameId'].astype(str) + extra_feat['eventTeam'].astype(str) + extra_feat['period'].astype(str) + extra_feat['periodTime'].astype(str)
#Merge the dataframes according to identifier column
df_merge = df.merge(extra_feat, how = 'left', left_on=['identifier'], right_on=['identifier'])
df_merge
# Drop the duplicate columns
df_merge = df_merge.drop(columns=['identifier', 'gameId_y', 'season_y',
       'teamHome_y', 'teamAway_y', 'eventType_y', 'eventTeam_y', 'period_y',
       'periodTime_y', 'eventSide_y', 'coordinateX_y', 'coordinateY_y',
       'shooterName_y', 'goalieName_y', 'shotType_y', 'emptyNet_y',
       'strength_y'])
df_merge = df_merge.rename(columns={'gameId_x':'gameId', 'season_x':'season', 
                'teamHome_x':'teamHome', 'teamAway_x':'teamAway', 
                'eventType_x':'eventType','eventTeam_x':'eventTeam',
                'period_x': 'period', 'periodTime_x': 'periodTime',
                'eventSide_x': 'eventSide', 'coordinateX_x': 'coordinateX',
                'coordinateY_x': 'coordinateY', 'shooterName_x': 'shooterName', 
                'goalieName_x': 'goalieName','shotType_x': 'shotType', 
                'emptyNet_x': 'emptyNet', 'strength_x': 'strength'})
df = df_merge



def home_to_friendly(eventTeam,teamHome,homePlayersOnice,awayPlayersOnice):
    """
    Takes data about the event and returns the number of friendly players on the ice.
    """
    # If the team taking the shot is the same as the home team (ie home = friendly):
    if eventTeam == teamHome:
        # Return the home players on ice == friendly players on ice
        return homePlayersOnice
    else:
        # Otherwise, the team taking the shot is the away team, so away=friendly
        return awayPlayersOnice
    
def home_to_opposing(eventTeam,teamHome,homePlayersOnice,awayPlayersOnice):
    """
    Takes data about the event and returns the number of opposing players on the ice.
    """
    # if the team taking the shot is the same team as the home team (ie. home = friendly, away = opposing):
    if eventTeam == teamHome:
        # return the away players on ice == opposing players on ice
        return awayPlayersOnice
    else:
        # Otherwise, the team taking the shot is the away team, so home = opposing and away = friendly
        return homePlayersOnice



# Again use clunky list comprehensions to add friendly players on ice and opposing players on ice features
df['friendlyPlayersOnIce'] = [home_to_friendly(df['eventTeam'][i],
                                               df['teamHome'][i],
                                              df['homePlayersOnIce'][i],
                                              df['awayPlayersOnIce'][i]) for i,r in df.iterrows()]
df['opposingPlayersOnIce'] = [home_to_opposing(df['eventTeam'][i],
                                               df['teamHome'][i],
                                              df['homePlayersOnIce'][i],
                                              df['awayPlayersOnIce'][i]) for i,r in df.iterrows()]



# Save the lists into a new dataframe
data = pd.DataFrame({'gameId': df['gameId'].astype(str),

                     'time': df['gameSeconds'],
                     'period': df['period'],
                     'coordinateX': df['coordinateX'],
                     'coordinateY': df['coordinateY'],
                     'shotDistance': df['distanceFromNet'],
                     'shotAngle': df['angleFromNet'],
                     'shotType': df['shotType'],
                     'shotType': df['shotType'],
                     'emptyNet': df['emptyNet'],

                     'lastEventType' : df['lastEventType'],
                     'lastCoordinateX': df['last_coordinateX'],
                     'lastCoordinateY': df['last_coordinateY'],
                     'lastTime': df['time_from_lastEvent'],
                     'lastShotDistance': df['last_distanceFromNet'],

                     'rebound': df['rebound'],
                     'changeShotAngle': df['changeShotAngle'],
                     'speed': df['speed'],

                     'friendlyPlayersOnIce': df['friendlyPlayersOnIce'],
                     'opposingPlayersOnIce': df['opposingPlayersOnIce'],
                     'timeSincePP': df['timeSincePP'],

                     'isGoal': df['isGoal'],
                    })


# features: <br>
# <br>
# gameSeconds: Game seconds (in seconds)(int)<br>
# period: Game period (int)<br>
# coordinateX, coordinateY: Coordinates (x,y, separate columns) (floats)<br>
# distanceFrom Net : Shot distance (float)<br>
# angleFromNet: Shot angle (in degrees)(float)<br>
# shotType: Shot type (str) <br>
# <br>
# lastEventType: Last event type (str) <br>
# last_coordinateX, last_coordinateY: Coordinates of the last event (x, y, separate columns) <br>
# time_from_lastEvent: Time from the last event (in seconds) (int) <br>
# last_distanceFromNet: Distance from the last event (float) <br>
# <br>
# rebound: Rebound (bool): True if the last event was also a shot, otherwise False (bool) <br>
# changeShotAngle: Change in shot angle; only include if the shot is a rebound, otherwise 0. (in degrees)(float) <br>
# speed: “Speed” defined as the distance from the previous event, divided by the time since the previous event. (float) <br>
# <br>
# friendlyPlayersOnIce: number of friendly players on ice as shot taken (int) <br>
# opposingPlayersOnIce: number of opposing players on ice as shot taken (int) <br>
# timeSincePP: seconds since powerplay started (int) <br>
# 

# Game IDs 02 = regular season, 03 = playoffs

# Filter data for regular season only
regular_data = data[data['gameId'].astype(str).str[4:6] == '02']
# Now that data are treated the same, divide into train, test_regular and test_playoff datasets
train_data = regular_data[(regular_data['gameId'].str[:4] == '2015') | (regular_data['gameId'].str[:4] == '2016') | (regular_data['gameId'].str[:4] == '2017') | (regular_data['gameId'].str[:4] == '2018')]
test_data_regular = regular_data[regular_data['gameId'].str[:4] == '2019']

# Filter data for playoffs only
playoff_data = data[data['gameId'].astype(str).str[4:6] == '03']
test_data_playoff = playoff_data[playoff_data['gameId'].str[:4] == '2019']


#Check that train data contains only the right seasons
print(f'train data:')
print(train_data['gameId'].str[:4].unique())
#Check that test data contains only the right seasons
print(f'test data regular season: ')
print(test_data_regular['gameId'].str[:4].unique())
print(f'test data playoffs: ')
print(test_data_playoff['gameId'].str[:4].unique())


# output to csv
train_data.to_csv('data/train.csv', index=False)
test_data_regular.to_csv('data/test_regular.csv', index=False)
test_data_playoff.to_csv('data/test_playoff.csv', index=False)
